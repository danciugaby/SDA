\chapter{Introducere}
\label{intro}%

Pentru început ne vom familiariza cu principiile, notaţiile folosite de-a lungul întregului curs.
Vom începe printr-o plasare a conceptului de algoritm în raport cu problemele reale utilizând un exemplu clasic. Vom prezenta conceptul de pseudocod și de asemenea vom folosi un exemplu de algoritm ușor de înteles. În finalul acestui capitol vom analiza algoritmii din punct de vedere a timpului de execuție al acestora. 

Ce fel de probleme se rezolvă cu ajutorul algoritmilor? Să zicem că aproape orice aplicație dezvoltată conține un algoritm (nu neapărat în forma lui didactică). De la rețele de socializare, la comerț electronic, la industrie, în aproape orice domeniu legat mai mult sau mai puțin de știința calculatoarelor, vom găsi necesitatea implementării cel puțin a unui algoritm.

Primul aspect care trebuie definit este ce reprezintă un agloritm. Există în mod evident mai multe căi de a defini un algoritm și vom enumera în cele ce urmează câteva dintre acestea:

\begin{itemize}
\item \large{Un algoritm este o procedură bine definită ce are ca intrare un set de valori sau una singură, și va produce una sau mai multe ieșiri.}
\item \large{Un algoritm reprezintă un set de reguli definit pentru a rezolva o problemă într-un număr finit de pași.}
\item \large{Un set de pași pentru a rezolva o problemă matematică sau pentru a realiza un proces computațional.}
\end{itemize}

Dacă un algoritm este o propunere conceptuală pentru a rezolva o problemă, atunci programul reprezintă forma implementată într-un limbaj specific. De regulă un program rezolvă mai multe probleme, ceea ce duce la necesitatea divizării în subprograme numite module. Fiecare modul poate conține implementarea unui algoritm sau o îmbinare a mai multor algoritmi.

Orice algoritm trebuie să poată fi definit prin:

\begin{itemize}
	\item {Intare. Se poate ca un algoritm să nu conțină nicio dată ca intrare sau să aiba un set de date ce definește intrarea.}
	\item {Ieșire. Fiecare algoritm are definită cel puțin o ieșire ce reprezintă soluția oferită.}
	\item {Exprimare. Fiecare pas al algoritmului trebuie să fie clar.}
	\item {Finitidutine. Algoritmul trebuie să-și termine execuția după un număr finit de pași.}
	\item {Eficacitate. Fiecare pas trebuie să fie definit cât mai simplu pentru a putea fi executat rapid.}
	
\end{itemize}

După modul de implementare, algoritmii se pot cataloga astfel:

\begin{itemize}
	\item {Recursiv-Iterativ. Recursivitatea înseamnă pe scurt apelul unei funcţii in interiorul ei. Pe de cealaltă parte, un algoritm iterativ, presupune execuţia succesivă a instrucţiunilor.}
	\item {Serial-Paralel. Modul în care se execută pașii definiți într-un algoritm poate fi consecutiv sau concomitent.}
	\item {Deterministic-Aleatoriu. Un algoritm deterministic va furniza pentru aceleași intrări un set de ieșiri care nu se va schimba oricâte rulări am avea. Pe de altă parte un algoritm aleatoriu, va produce pentru aceeași intrare la rulări diferite, ieșiri diferite.}
\end{itemize}

În continuare vom prezenta un exemplu pentru a defini câteva modalități de a exprima un algoritm.

\section{Exemplu introductiv}

Pentru a exemplifica câteva moduri de a reprezenta pașii un algoritm putem folosi pentru început problema găsirii minimului într-un șir.

Iată cum putem defini problema găsirii minimului dintr-un șir:

\textbf{Intrare: } O secvență de $n$ numere 
\textbf{Ieșire: } Valoarea celui mai mic număr din secvență

Fie secvența $(12,23,7,18,4,35,16)$. Evident numărul minim se va afla parcurgând acest șir si reținând valoarea minimă, în acest caz 4.
În figura \ref{fig:minimum} este reprezentată această parcurgere.

\begin{figure} %  \VR and h=here, t=top, b=bottom
  \centering
  \ifthenelse{\boolean{SUBCAPTIONS}}{
	  \begin{subfigure}{0.6\textwidth}
	    \Image[width=\textwidth]{/introducere/sirinitial}
	    \caption{Sirul inițial. Cu gri sunt indicate indexurile valorilor din șir}
	    \label{fig:flower1}
	  \end{subfigure}
	  \begin{subfigure}{0.7\textwidth}
	    \Image[width=\textwidth]{/introducere/minfinal}
	    \caption{Parcurgerea șirului și reținerea minimului}
	    \label{fig:flower2}
	  \end{subfigure}
  }{
    \Image[width=0.85\textwidth]{Aflarea minimului dintr-un șir}  
  }
  \caption{Aflarea minimului dintr-un șir} 
  \label{fig:minimum}
\end{figure}

Există cel puțin trei tipuri de a exprima un algoritm astfel încât descrierea pașilor acestuia să nu depindă de niciun limbaj de programare:
\begin{enumerate}
	\item {Exprimare în limbaj natural. Aceasta presupune descrierea în cuvinte a pașilor.}
	\item {Pseudocod. Descrierea are loc sub forma unui cod ce poate fi ușor transcris apoi în orice limbaj de programare.}
	\item {Schemă logică. Un algoritm poate fi reprezentat sub o formă vizuală ușor de descris și de urmărit.}
\end{enumerate}

În cele ce urmează vom parcurge cele trei moduri de a implementa algoritmul de aflare a minimului dintr-un șir.
Primul mod de a descrie un agloritm este tocmai expunerea pașilor în cuvinte precum în algoritmul \ref{alg:pasiiinscris}.

\begin{algorithm}

	(I) Inițializează o variabilă $min$ cu valoarea primului element din șir\\
	(II) Parcurge tot restul șirului folosind o variabilă $i$ pentru a incrementa poziția în șir\\
	(III) Reține valoarea minimă în $min$ comparând această variabilă cu fiecare element din șir
	\vspace*{0.5cm}
	\caption{Algoritm exprimat în limbaj natural}
	\label{alg:pasiiinscris}
\end{algorithm}

Al doilea mod este cel mai răspândit și anume pseudocodul din algoritmul \ref{alg:pseudocod}. Vom detalia în secțiunea următoare regulile pentru a scrie un algoritm în pseudocod.

O schemă logică este o diagramă ce reprezintă grafic pașii unui algoritm folosind blocuri conectate de săgeți ce indică fluxul datelor.
Blocurile sunt diferite forme geometrice ce semnifică instrucțiuni logice: dreptunghi-asignare, cerc-conector, romb-instrucțiune condițională, etc.

\begin{algorithm}
	\caption{Algoritm exprimat în pseudocod}\label{alg:pseudocod}
	\begin{algorithmic}[1]
		\Procedure{Find\_Min}{$A$}\Comment{Find minimum in A}
		\State $min\gets A[1]$
		\State $i\gets 2$
		\State $n\gets length(A)$
		\While{$i <= n$}
		\If{min > A[i]}		
		\State $min \gets A[i]$
		\EndIf
		\State $i\gets i+1$
		\EndWhile\label{pseudocodwhile}
		\State \textbf{return} $min$\Comment{The minimum of $A$ is $min$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

După cum se poate observa acest mod de descrie un algoritm este ceva mai complicat, se folosesc anumite notații specifice ceea ce implică respectarea unor reguli de scriere. 

Ultima modalitate de a descrie un algoritm este schema logică iar un exemplu este oferit mai jos în figura \ref{fig:schemalogica}.

\begin{figure}[H] %  \VR and h=here, t=top, b=bottom
	\centering	
	{
		\Image[width=0.8\textwidth]{/introducere/schemalogica}
	}
	\caption{Aflarea minimului dintr-un șir. Schema logică.} 
	\label{fig:schemalogica}
\end{figure}




\pagebreak



\section{Analiza algoritmilor}

A analiza un algoritm poate însemna a prezice resursele necesare ca acesta să ruleze.
Înainte de a analiza un algoritm, trebuie să avem un model al tehnologiei pe care va fi
implementat. Vom presupune faptul că va rula pe un sistem cu un procesor, iar instrucţiunile vor fi
executate una după alta, fără operaţii concurente. 
Înainte de a analiza algoritmii va trebui să stabilim regulile de exprimare a acestora. 

\subsection{Convențiile pentru pseudocod}

Pentru a folosi corect și constant, în cele ce urmează, limbajul pseudocod, trebuie să ţinem cont
de anumite reguli și anume:

\begin{enumerate}
\item {
	Identarea indică o structură bloc (while, if, etc). În exemplul din algoritmul \ref{alg:pseudocod}, corpul procedurii ce
	începe pe linia 2 constă din liniile 2-11, sau corpul while-ului ce începe pe linia 5 și conţine
	liniile 6-9, sunt exemple de instrucțiunii din cadrul unui bloc.
	În loc de identare se pot folosi paranteze, acolade sau specificatori begin, end pentru a spori claritatea codului.
}
\item {
	Simbolul $\rhd$ indică faptul că ceea ce urmează după el reprezintă un comentariu.
}
\item {
	Atribuirea se face folosind operatorul „$\leftarrow$” .De exemplu i ia valoarea lui j se va scrie i $\leftarrow$ j. Ese posibil ca în alte notații atribuirea să se facă folosind „$:=$”.
}
\item {
	Egalitatea se verifică folosind operatorul „$=$” .De exemplu i egal cu j se va scrie i $=$ j
}
\item {
	Variabilele (de exemplu $i$ sau $j$) sunt locale în procedura respectivă. Nu vom folosi variabile globale în pseudocod.
}
\item {
	Șirurile se vor reprezenta prin litere mari: A,B, accesarea unui element din șir se face utilizând paranteze pătrate ca de exemplu A[3]. Aici a fost accesat elementul cu indexul 3. Notaţia “..” este folosită pentru a indica un domeniu de valori din cadrul șirului. De exemplu A[1..j] indică subșirul ce este format din elementele A[1],A[2],...,A[j].	
}
\item {
	Parametrii sunt transmiși prin valoare, adică procedura primește copii ale parametrilor de la apel.
}
\item {
	Anumite funcții predefinite pot fi referite direct prin numele lor fără a fi necesar descrierea formală a acestora. De exemplu $min(a,b,c)$ va returna valoarea cea mai mică dintre $a$,$b$ și $c$.
}
\item {
	Atributele unor obiecte vor fi indicate prin cuvinte în engleză cu font italic. De exemplu dacă tratăm un șir ca obiect, atunci atributul $length$ va indica lungimea acestuia, adică numărul total de elemente ale șirului. Dacă dorim să reprezentăm un pointer, va trebui să marcăm acest lucru prin operaţia de atribuire. În alte notații lungimea șirului se indică folosind operatorul modul: $|A|$.
	Dacă avem două obiecte $x$ și $y$, iar operaţia $y  \leftarrow x$ produce egalitatea $f[x]=f[y]$ unde f este orice atribut al acestui obiect și apoi setăm $f[x] \leftarrow f[y]$ unde $f$ este orice atribut al acestui obiect și setăm $f[x] \leftarrow 3$, aceasta va produce automat $f[y]=3$.	
}
\item {
	Un obiect null va fi marcat cu valoarea NIL.
}

\end{enumerate}

\subsection{Analiza sortării prin inserție}


Timpul necesar sortării unui șir folosind această metodă, depinde de intrare: sortarea unui șir de mii de elemente este evident, mai lentă, decât sortarea unui șir cu zece elemente. Pentru a putea cuantifica acest timp, în raport cu intrarea, va trebui să definim noţiunea de \textit{timp de rulare} și noţiunea de $intrare$ mai amănunţit.

Noţiunea de \textit{mărime de intrare} depinde de problema studiată. De exemplu înmulţirea a doi întregi, este în strânsă relaţie cu numărul de biţi necesari reprezentării acelor numere. Pe de altă parte sortarea unui șir depinde de numărul de elemente ale acelui șir.

Noţiunea de \textit{timp de rulare} înseamnă mai degrabă numărul de operaţii (pași) care trebuie executate pentru a rula algoritmul. Este mai bine să folosim termenul de $pas$ pentru a nu lega noţiunea de operaţie de o arhitectură anume. Pentru a cuantifica cât mai corect timpul de rulare, vom introduce și noţiunea de constantă ce reprezintă timpul necesar execuţiei unei instrucţiuni.

De exemplu pentru a executa linia $i$, putem preciza constanta ca fiind timpul necesar execuţiei acelei linii. Vom denumi această constantă, costul unei operaţii. În continuare vom analiza, pornind de la algoritmul descris anterior timpul de execuţie al sortării prin inserţie:
\newcounter{themenumber}	
\begin{algorithm}
	\caption{Sortarea prin inserție}\label{alg:insertie}
	\begin{algorithmic}[1]
	
	\Procedure{Insertion\_Sort}{$A$} \hfill const \tab{timpi} \tab{}
		\For {j $\gets$ 1 \textbf{to} n}  \hfill $c_1$ \tab{$n$} \tab{}
		\State $key\gets A[j]$ 		 	 \hfill $c_2$ \tab{$n-1$} \tab{} \\
		\Comment{insert $A[j]$ into sorted sequence $A[i..j-1]$} \hfill $0$ \tab{$n-1$} \tab{}
		\State $i \gets j-1$ 			\hfill $c_4$ \tab{$n-1$} \tab{}
		\While{$i > 0  \hspace{3pt} AND  \hspace{3pt} A[i]>key$}	\hfill $c_5$  \tab{$\sum_{j=2}^{n}t_{j}$} \tab{}
		\State $A[i+1] \gets A[i]$ 				\hfill $c_6$ \tab{$\sum_{j=2}^{n}(t_{j}-1)$}  \tab{}
		\State $i \gets i-1$ 				\hfill $c_7$  \tab{$\sum_{j=2}^{n}(t_{j}-1)$}		\tab{}
		\EndWhile\label{pseudocodwhile}	
		\State $A[i+1] \gets key$ 				\hfill $c_8$ \tab{$n-1$} \tab{}
		\EndFor		
		\EndProcedure
	\end{algorithmic}
\end{algorithm}



\textit{Timpul de rulare} al algoritmului este suma timpilor necesari rulării fiecărei operații. În cazul unei operaţii simple (ca în cazul $for$, se va înmulţi costul cu numărul de execuţii al acelei operaţii). Numărul de execuţii este ceva mai complicat în cazul operaţiei $while$ din interiorul forului. Deoarece nu putem spune cu siguranţă de câte ori se va executa fiecare $while$, aceasta depinzând de \textbf{intrare} și anume de șirul de sortat. De aceea presupunem că $t_j$ este numărul de execuţii în while pentru un anumit $j$.

Putem încerca în continuare să stabilim numărul total de execuţii, și ca atare timpul de rulare total $T(n)$:

\begin{equation}
\begin{multlined}
T(n) = c_{1}n+c_{2}(n-1)+c_{4}(n-1) + \\ c_{5}\sum_{j=2}^{n}t_{j}+c_{6}\sum_{j=2}^{n}(t_{j}-1)+c_{7}\sum_{j=2}^{n}(t_{j}-1)+c_{8}(n-1)
\end{multlined}
\end{equation}

În cel mai bun caz, și anume când șirul de intrare este deja sortat (instrucţiunea 5.) este executată doar pentru a efectua o verificare, și nu se vor executa niciodată instrucţiunile 6. și 7. În acest caz putem rescrie $T(n)$ considerând $\sum_{j=2}^{n}t_{j} = \sum_{j=2}^{n}1 = n-1$.

Asfel timpul total de rulare va fi:

\begin{equation}
\begin{multlined}
T(n) = c_{1}n+c_{2}(n-1)+c_{4}(n-1) + c_{5}(n-1)+c_{8}(n-1) = \\( c_{1}+ c_{2}+ c_{4}+ c_{5}+ c_{8}) - ( c_{2}+ c_{4}+ c_{5}+ c_{8})
\end{multlined}
\end{equation}

Aceasta poate fi scrisă sub forma $an+b$ unde $a$ și $b$ sunt constante ce depind de $c_i$. Aceasta înseamnă că $T(n)$ este o funcție liniară de $n$.

În cazul în care șirul este scortat descrescător, calculând $T(n)$ obținem cel mai slab timp din punct de vedere al eficienței. Astfel instrucțiunea $while$ va fi executată de fiecare dată iar $t_{j}=j$:

\begin{equation}
\sum_{j=2}^{n}t_{j} = \sum_{j=2}^{n}j = \frac{n(n+1)}{2}-1
\end{equation}

și

\begin{equation}
\sum_{j=2}^{n}(t_{j}-1) = \sum_{j=2}^{n}(j-1) = \frac{n(n-1)}{2}
\end{equation}

Înlocuind în formula de calcul al lui $T(n)$ obținem:

\begin{equation}
\begin{multlined}
T(n) = c_{1}n+c_{2}(n-1)+c_{4}(n-1) + \\c_{5}(\frac{n(n+1)}{2}-1)+  c_{6}(\frac{n(n-1)}{2})+ c_{7}(\frac{n(n-1)}{2})+ c_{8}(n-1) = \\ ( \frac{c_{5}}{2}+  \frac{c_{6}}{2}+  \frac{c_{7}}{2})n^{2} + ( c_{1}+ c_{2}+ c_{4}+ \frac{c_{5}}{2} -  \frac{c_{6}}{2}  - \frac{c_{7}}{2} + c_{8})n - ( c_{2}+ c_{4}+ c_{5}+ c_{8})
\end{multlined}
\end{equation}

Acest timp poate fi exprimat sub forma $f = an^{2} + bn+c$ cu $a$,$b$ și $c$ depinzând de constantele $c_{1..8}$.

\subsection{Ordinul de timp}

Am simplificat unele calcule pentru a ușura cât mai mult analiza algoritmului de inserţie. De exemplu, am ignorat costul concret al fiecărei instrucţiuni folosind constante de tip $c_i$. În cazul cel mai nefavorabil am ales constantele  $a$,$b$ și $c$ pentru a arata faptul că polinomul este de ordinul 2. Pentru a simplifica și mai mult lucrurile vom proceda la următoarea notație. Se numește \textbf{ordin de creștere} acel timp de rulare dedus din funcția $f$ ce reprezintă cel mai bine numărul de pași necesari execuției unui algoritm. Acest număr de pași este corelat cu timpul necesar rulării unui algoritm.

Din funcția $f$ vom considera cel mai reprezentativ termen și anume $an^2$, deoarece pentru un $n$ suficient de mare, ceilalți termeni vor fi mici relativ la $an^2$. Mai mult, vom ignora coeficientul, din moment ce aceștia sunt mai puţin semnificativi în determinarea ordinului de creștere.  De aceea, obţinem pentru acest algoritm, în cel mai nefavorabil caz, timpul de rulare de $O(n^2)$, notaţie pe care o vom detalia în capitolul următor.

În cazul în care șirul de intrare ar fi fost deja sortat $T(n)$ ar fi fost sub forma $f = an+b$. Aceasta înseamnă că doar pentru acest caz timpul de rulare ar fi fost timpul de rulare de $O(n)$. Pentru a surprinde ambele cazuri există notații asimptotice pe care le vom studia ulterior.

De ce trebuie ca algoritmul să fie eficient, și ordinul de timp să fie cât mai mic? Pentru că un algoritm reprezintă o tehnologie. Astfel acesta va evolua inevitabil, în strânsă legătură cu platformele pe care a fost implementat. Independent însă de aceste platforme, un algoritm poate fi îmbunătățit astfel încât să producă aceleași rezultate mai rapid ceea ce înseamnă un progres al tehnologiei folosite.


Luând în considerare o serie de factori precum limbajul în care este scris algoritmul, mediul în care va rula programul ce implementează algoritmul, putem extinde analiza de bază care va fi prezentată în acest curs, pentru a prezice cu acurateţe timpul necesar rulării unui program, pentru diferite intrări. 

Totuși, în cadrul acestui curs vom ignora aceste aspecte, pentru a păstra simplitatea calcului, și a ușura înţelegerea modelelor descrise. În cele ce urmează, vom studia fundamentele matematice care ne vor fi de mare folos în analiza tuturor algoritmilor ce vor fi studiaţi.

\section{Algoritmi fundamentali}

În continuare, vom prezenta câţiva algoritmi nu foarte complicaţi, pentru a crea
introducere pentru acest curs și pentru a exersa conceptele de mai sus și nu numai.

\subsection{Înmulțirea a la russe}


Este o operaţie de matematică cu origini în Egiptul antic, și este o metodă ce nu implică folosirea tabelului înmulţirii, ci doar divizarea cu 2 și adunarea. Marele avantaj al acestei metode este că poate fi implementată ușor în tehnica de calcul modernă, deoarece implică folosirea acestor două operaţii aritmetice
de bază.

Iată un exemplu pentru a demonstra principiul, înmulţind numerele 52 și 15:

\begin{table}[h]
	\centering
	\begin{tabular}{ c c c }
		52 & 15 & -- \\ 
		26 & 30 & -- \\  
		13 & 60 & 60 \\    
		6 & 120 & -- \\    
		3 & 240 & 240 \\   
		1 & 480 & 480 \\    
		 \hline 
		 &  & 780 \\     
	\end{tabular}
	\caption{Înmulțirea a la russe pentru numerele 52 și 15}
	\label{table:alarusse}
\end{table}

După cum se poate observa în tabelul \ref{table:alarusse}, se aplică în mod repetat împarțirea cu 2 a primului număr și inmulțirea cu 2 a celui de al doilea număr.

 În cazul în care împărțirea cu 2 a primului număr a avut ca rezultat un număr impar (în prima coloană), se reține rezultatul înmulțirii cu 2 a celui de-al doilea număr (în a doua coloană). În a treia coloană stocăm aceste rezultate parțiale. La final însumăm numerele din a treia coloană și acesta este produsul dintre 52 și 15.

În cele ce urmează vom descrie acest algoritm (\ref{alg:russe}) folosind pseudocod.

\begin{algorithm}
	\caption{Înmulțirea a la russe}\label{alg:russe}
	\begin{algorithmic}[1]
		
		\Procedure{Russe}{$a,b$} 
		\State \textbf{arrays} $X,Y$
		\State $X[1] \gets a;Y[1] \gets b$
		\State $i \gets 1$	\\	
		\Comment{se construiesc cele două coloane} \hfill \tab{}\tab{}\tab{}\tab{}
		\While{$X[i]>1$}
		\State $X[i+1] \gets X[i] / 2$
		\State $Y[i+1] \gets Y[i] + Y[i]$
		\State $i \gets i+1$
		\EndWhile
		\State $prod \gets 0$
		\While{$i>0$}
		\If {$X[i] \%2 = 0$}		
		\State $prod \gets prod + Y[i]$
		\EndIf
		\State $i \gets i-1$
		\EndWhile \\
		\Return $prod$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Ordinul de timp al acestui algoritm este \textit{O(n)}, iar pseudocodul prezentat poate fi optimizat adică se poate elimina a doua buclă \textbf{while} și de asemenea se pot elimina cele două șiruri auxiliare $X$,$Y$.

Întrebarea firească este de ce funcționează acest algoritm? Răspunsul poate fi dat transformând numerele în sistemul binar. În această bază, împărțirea la 2 este echivalentul șiftării tuturor biților la dreapta cu o unitate. Asemenea înmulțirea cu 2 reprezintă șiftarea tuturor biților la stânga cu o unitate și completarea cu 0 a bitului cel mai din dreapta.

De exemplu numărul 14 în binar este 1110. Dacă ar fi să îl înmulțim cu 1 tot în binar, acesta devine: $14 = 1*2^{3} + 1*2^{2} + 1*2^{1} + 0*2^{0} $. 
Se poate observa că doar puterile lui $2$ înmulțite cu $1$ contează în suma finală.

Mai departe să înmulțim 14 cu 2. Adică 1110 cu \textbf{1}\textit{0} în binar: $14*2 = 28 + 0 = 11100*\textbf{1}  + 1110*\textit{0}  =1*2^{4} +  1*2^{3} + 1*2^{2} + 0*2^{1} + 0*2^{0}$. După cum se poate vedea, acel \textit{0} marcat cu font italic nici nu a contat în suma finală. De aceea nici algoritmul nu ia in calcul numere pare din coloana a doua. 

Această metodă are aplicații în domeniul educațional, fiind o metodă ușor de înțeles și de implementat, dar și în domeniul ingineresc deoarece aduce o îmbunătărire a timpului de execuție acolo unde numerele sunt foarte mari. 
Această problemă poate fi încadrată la categoria \textit{divide et impera} despre care vom vorbi în capitolul dedicat acestui tip de rezolvare.

\subsection{Sortarea prin selecție}

Algoritmul are ca intrare un șir de date, nu neapărat sortat, și se cere sortarea crescător a acestuia. Spre deosebire de sortarea prin inserţie, sortarea prin selecţie, lucrează altfel, plasând la fiecare pas un element pe poziţia lui finală.

\begin{algorithm}
	\caption{Sortare prin selecție}\label{alg:selectie}
	\begin{algorithmic}[1]
		
		\Procedure{Selection\_Sort}{$A[1..n]$} 
		\For {i $\gets$ 1 \textbf{to} n-1}
		\State $minj \gets i;minx \gets A[i]$\\
		\Comment{caut poziția finală a lui A[i] în șir} \hfill \tab{}\tab{}\tab{}
		\For {j $\gets$ i+1 \textbf{to} n}
		\If {$A[j]<minx$}		
		\State $minj \gets j$
		\State $minx \gets A[j]$
		\EndIf
		\EndFor \\
		\Comment{la final schimb elementul actual cu cel mai mic găsit} \hfill \tab{}
		\State $A[minj] \gets A[i]$
		\State $A[i] \gets minx$
		\EndFor 
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algoritmul \ref{alg:selectie} funcţionează astfel: pornind de la primul element în șir, ne folosim de variabile auxiliare \textit{minj} și \textit{minx} pentru a reţine poziţia celui mai mic element respectiv valoarea acestuia. Apoi vom parcurge restul șirului căutând cel mai mic element din subșirul care este format din elementele ce urmează elementului actual. Găsim cea mai mică valoare, reţinem poziţia, și facem interschimbarea cu elementul actual (daca este cazul). Continuăm până când am parcurs șirul până la penultimul element, clipă în care șirul va fi deja sortat.

Pentru exemplificare vom utiliza ca intrare șirul \{5, 2, 4, 6, 1, 3 \}, pașii acestui algoritm fiind descriși, vizual, în figura \ref{fig:sortareselectie}.

Ordinul de timp al acestui algoritm este $O(n^{2})$, independent de ordonarea iniţială a elementelor. 

\begin{figure}[H] %  \VR and h=here, t=top, b=bottom
	\centering	
	{
		\Image[width=0.6\textwidth]{/introducere/sortareselectie}
	}
	\caption{Exemplu pentru algoritmul de sortare prin selecție} 
	\label{fig:sortareselectie}
\end{figure}

Acest tip de sortare este destul de rapid pentru șiruri relativ mici (sub 100 elemente). Sortarea fișierelor sau a folderelor, verificarea unicității unor elemente, selecția rapidă a celui de-al $k$ element dintr-un șir ordonat sunt câteva exemple de aplicații ale sortării. Vom vedea în capitolele ce urmează, diferite optimizări ale acestei probleme.


\subsection{Șirul lui Fibonacci}


Șirul lui Fibonacci este definit prin următoarea recurenţă:

\begin{equation}
\left\{\begin{matrix}
f_{0}=0, f_{1}=1 &  \\ n < 2
f_{n} =  f_{n-1} + f_{n-2} & n\geq 2
\end{matrix}\right.
\end{equation}


Acest șir a fost descoperit de Leonardo Pisano, cunoscut sub numele Leonardo Fibonacci. Cel de-al n-lea termen din șir se poate scrie folosind definiţia și anume conform algoritmului \ref{alg:fibor}.

\begin{algorithm}
	\caption{Calculul termenului $n$ al șirului Fibonacci.\\ Varianta recursivă}\label{alg:fibor}
	\begin{algorithmic}[1]		
		\Procedure{FIBO\_R}{$n$} 
		\If {$n<2$}	 \hspace{3pt}
		\Return n			
		\Else \hspace{3pt}
		\Return FIBO\_R(n-1) + FIBO\_R(n-2)
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Metoda este extrem de ineficientă, deoarece recalculează de mai multe ori aceleași valori, ordinul de timp fiind unul exponenţial $O(\phi^{n})$. Vom lămuri în capitolul dedicat calculului complexității algoritmilor. Acest algoritm introduce noţiunea de recursivitate, asupra căreia vom insista ulterior în curs.
Motivul pentru care acest algoritm este extrem de ineficient este pentru că în calculul termenului $n$ se repetă (inutil) calculul termenilor inferiori după cum reiese din figura \ref{fig:fibor}.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=0.8\textwidth]{/introducere/fibor}
	}
	\caption{Calculul termenului 5 al șirului Fibonacci folosind algoritmul \ref{alg:fibor}.} 
	\label{fig:fibor}
\end{figure}

O altă metoda mai eficientă de a rezolva această problemă, și anume într-un timp liniar $O(n)$, este prezentată în algoritmul \ref{alg:fiboi}. Această versiune reprezintă defapt o metodologie de a elabora algoritmi și anume \textit{programarea dinamică}, despre care vom vorbi în capitolul rezervat acesteia.


\begin{algorithm}[H]
	\caption{Calculul termenului $n$ al șirului Fibonacci.\\ Varianta iterativă}\label{alg:fiboi}
	\begin{algorithmic}[1]
		\Procedure{FIBO\_I}{$n$} 
		\State $i \gets 0; j \gets 1$
		\State $s \gets 1$
		\For {k $\gets$ 1 \textbf{to} n}
		\State $i \gets j$
		\State $j \gets s$
		\State $s \gets i+j$
		\EndFor \\
		\Return $i$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Secvența Fibonacci are o semnificație mai mare decât cea educațională. În lumea naturală există diferite specii de plante care se dezvoltă în conformitate cu această serie sau au în componență părți ce pot fi aproximate cu ajutorul acestui șir. De asemenea, anumite metodologii de dezvoltare și estimare de applicații software, folosesc seria Fibonacci pentru a determina timpul necesar rezolvării unui proiect.

\subsection{Algoritmul lui Euclid}

Algoritmul ce poartă numele lui Euclid (posibil să fi fost descoperit înaintea matematicianului grec) este o metodă eficientă de a calcula CMMDC (cel mai mare divizor comun) a două numere întregi.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=0.8\textwidth]{/introducere/euclid}
	}
	\caption{Găsirea CMMDC-ului dintre numerele 102 și 18. Reprezentare vizuală} 
	\label{fig:euclid}
\end{figure}

Algoritmul \ref{alg:euclid} se bazează pe principiul că divizorul a două numere nu se schimbă dacă extragem numărul cel mai mic din cel mai mare. De exemplu CMMDC-ul lui 102 si 18 este 6. Dacă extragem 18 din 102 obţinem 84, iar CMMDC-ul lui 18 și 84 este tot 6. În figura \ref{fig:euclid} se poate observa calcului pentru a găsi CMMDC-ul dintre numerele alese pentru exemplificare și anume 102 și 18.




Algoritmul lui Euclid se bazează pe această proprietate și spune că CMMDC-ul a două numere se poate afla astfel: se află restul împărţirii celui mai mare număr la cel mai mic și se reţine acest rest, câtul și vechiul deîmpărţit devin noile numere cărora le aplicăm aceeași operaţie, până când restul devine zero. Penultimul rest este cmmdc-ul numerelor iniţiale. 

\begin{algorithm}[H]
	\caption{Algoritmul lui Euclid}\label{alg:euclid}
	\begin{algorithmic}[1]
		\Procedure{Euclid}{$m,n$} 
		\While {$n\neq 0$}
		\State $temp \gets n$
		\State $n \gets m\%n$
		\State $m \gets temp$
		\EndWhile \\
		\Return $m$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Pentru exemplul ales mai sus și anume 102 și 18 algoritmul va funcționa astfel:

\begin{algorithm}{}
	\begin{algorithmic}

		\State $temp \gets 18$
		\State $n \gets 12$
		\State $m \gets 18$
		\begin{addmargin}[2em]{0em}
		\State $temp \gets 12$
		\State $n \gets 6$
	    \State $m \gets 12$	
	    	\begin{addmargin}[2em]{0em}

		 \State $temp \gets 6$
		 \State $n \gets 0$
		 \State $\textbf{m} \gets \textbf{6}$
		 	    \end{addmargin}
		\end{addmargin}
	
	\end{algorithmic}
\end{algorithm}

Vom vedea că acest algoritm poate fi aplicat pentru a rezolva o problemă de tip \textit{bin packing} folosind metodologia \textit{greedy}.

Aplicațiile practice ale acestui algoritm variază de la simplificarea reprezentării fracțiilor, la construcția sistemului de criptare RSA \cite{Rivest:1978:MOD:359340.359342} sau la elaborarea strategiilor de tip \textit{look-ahead} precum \cite{Gragg1994}.

\subsection{Turnurile din Hanoi}


Problema turnurilor din Hanoi reprezintă un puzzle matematic format din 3 tije și $n$ discuri situate inițial pe prima tijă. Aceste discuri sunt plasate astfel încât la bază se află discul cu cel mai mare diametru, deasupra lui discul cu următorul diametru ca mărime ș.a.m.d. 

Scopul este de a transfera discurile pe ultima tijă (a treia) astfel încât niciodată să nu avem situația în care, pe orice tijă ne-am afla, să existe un disc cu diametru mai mare deasupra unui disc cu diametru mai mic.

Altfel spus, fie $n$ discuri 1,2,3,... cu diametrele $d_1$,$d_2$,$d_3$,... situate pe prima tijă, astfel încât $d_{1}>d_{2}>d_{3}...$, să se plaseze pe ultima tijă $n$ discuri 1,2,3... astfel ca ordinea să se mențină $d_{1}>d_{2}>d_{3}...$ pe a treia tijă.

Problema își are originile într-un templu indian din Varanasi, oraș cunoscut anterior ca Benares. Preoții aveau această sarcină de a muta $n=64$ de discuri de aur dintr-o parte a templului în alta, folosind o locație intermediară pentru a plasa aceste discuri. Deoarece discurile erau fragile, trebuia să se mențină ordinea indicată mai sus.

Vom vedea ulterior că algoritmul are ordinul de timp $O(n)=2^n$ ceea ce înseamnă că ar fi avut de efectuat $2^64$ pași. De aceea se spune că atunci când, ipotetic, ar fi terminat această sarcină, ar fi venit de mult sfârșitul lumii. Ceea ce nu este departe de adevăr pentru că această sarcină ar necesita un efort de sute de miliarde de ani, în cazul în care este executată de o singură persoană.

Iată câteva motive pentru care această problemă este relevantă:

\begin{itemize}
	\item{este un exemplu foarte bun de recursivitate}
	\item{jocul este folosit de neurofiziologi pentru a verifica defectele din lobul frontal}
	\item{ajută la stocarea datelor pentru a minimiza timpul de re-folosire al acestora}
	\item{este întâlnită și în lumea animală: o specie de furnici a folosit acest algoritm, într-un experiment efectuat în 2010 în care se observa căutarea celui mai scurt drum \cite{Reid50}}
\end{itemize}

În figura \ref{fig:hanoi} am reprezentat o soluție vizuală pentru acest algoritm cu $n=3$ discuri.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{/introducere/hanoi}
	}
	\caption{Rezolvarea algoritmului turnurilor din Hanoi. Reprezentare vizuală.} 
	\label{fig:hanoi}
\end{figure}

Iată și rezolvarea formală a acestei probleme:

\begin{itemize}
	\item{Se etichetează tijele cu A, B și C}
	\item{se numerotează discurile 1 - cel mai mic, n- cel mai mare}
\end{itemize}

Algoritmul recursiv este \ref{alg:hanoi}:

\begin{algorithm}[H]
	\caption{Algoritmul turnurilor din Handoi}\label{alg:hanoi}
	\begin{algorithmic}[1]
		\Procedure{Hanoi}{$n, A, B, C$} 
		\If {$n\neq 0$}\\
		\tab{}\Call{Hanoi}{$n-1, A, B, C$}
		\State $afisez \hspace{3pt} \textbf{<<Mută discul de pe>> A <<pe>> C} \hspace{3pt}$ \\
		\tab{}\Call{Hanoi}{$n-1, B, C, A$}
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Observăm că problema poate fi descompusă în trei subprobleme independente și anume mutarea a $n-1$ discuri, mutarea de pe A pe C și apoi mutarea a $n-1$ discuri. Din acest punct de vedere problema poate fi încadrată ca fiind \textit{divide et impera}.