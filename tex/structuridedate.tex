\chapter{Structuri de date}
\label{abody}%

Pe parcursul acestui curs vom vorbi despre algoritmi a căror implementare necesită utilizarea unor structuri de date specifice.
Ca atare acest capitol va trata structuri precum liste, tabele hash, grafuri, arbori ș.a.m.d.. Putem privi structurile de date ca un pas premergător studiului algoritmului deoarece există o interdependență între algoritm și structura aleasă.

\section{Șiruri}

Un șir $A$ este o structură lineară alocată ca un bloc omogen de date în care datele sunt poziționate în locații consecutive. Indexarea acestor locații începe cu poziția 1 și se termină cu $n=length(A)$. 

Aceste date pot avea un tip standard, precum întreg, string, caracter etc. Figura \ref{fig:minimum} prezintă cel mai bine un șir de 7 întregi cu valorile {12, 23, 7, 18, 4, 35, 16}. De regulă, nu există nici o restricție cu privire la relațiile între date (exemplu: ordonare, unicitate) într-un șir, cu excepția în care problema dată specifică aceste restricții.

În continuare vom studia câteva dintre operațiile cu șiruri.

\subsection{Căutarea în șir}

Căutarea unui element într-un șir este relativ simplu și presupune o parcurgere. Procedura se numește căutare lineară datorită ordinului de timp $O(n)$. Algoritmul pentru aceasta este \ref{alg:cautlinear}.

\begin{algorithm}[H]
	\caption{Algoritmul de căutare în șir}\label{alg:cautlinear}
	\begin{algorithmic}[1]
		\Procedure{Căutare\_lineară}{$A[1..n],x$} 
		\State $flag \gets false$
		\State $i \gets 1$
		\While {$i \leq n$}
		\If {$A[i]=x$}
		\State $flag \gets true$
		\State \textbf{break}
		\EndIf 
		\State $i \gets i+1$
		\EndWhile 
		\If {$flag = false$}
		\State $print \textit{<<Not found>>}$
		\EndIf 
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsection{Inversarea elementelor într-un șir}

Algoritmul ce inversează ordinea inițială a elementelor este \ref{alg:inversez}.


\begin{algorithm}[H]
	\caption{Algoritmul de inversare a elementelor într-un șir} \label{alg:inversez}
	\begin{algorithmic}[1]
		\Procedure{Inversare}{$A[1..n]$} 
		\State $i \gets 1$	
		\While {$i \leq n/2$}
		\State $aux \gets a[i]$
		\State $a[i] \gets a[n-i-1]$
		\State $ a[n-i-1] \gets aux$
		\State $i \gets i+1$		
		\EndWhile 
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Figura \ref{fig:inversare} prezintă acest algoritm pornind de la șirul ales la începutul secțiunii.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=0.8\textwidth]{structuridedate/inversare}
	}
	\caption{Inversarea elementelor într-un șir.} 
	\label{fig:inversare}
\end{figure}

Acest algoritm este de tipul "in-place" deoarece pașii acestuia nu necesită utilizarea unei alte structuri, valorile fiind înlocuite în cadrul aceluași șir inițial. Vom vedea că acest exercițiu este util mai ales în cazul unor sortări.

\subsection{Șiruri bidimensionale}

Un șir 2D este o matrice. Pentru a parcurge și a accesa elementele unei matrice avem nevoie de 2 indecși după cum este indicat în algoritmul \ref{alg:matrixparcurg}.

\begin{algorithm}[H]
	\caption{Parcurgere și inițializare elemente matrice}\label{alg:matrixparcurg}
	\begin{algorithmic}[1]
		\Procedure{Matrix\_Init}{$A,m,n$} 
		\For {i $\gets$ 1 \textbf{to} n}	
		\For {j $\gets$ 1 \textbf{to} m}
		\State $A[i][j] \gets i*j$
		\EndFor 
		\EndFor 
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


O matrice $A$ cu $n$ linii și $m$ coloane poate fi parcursă într-un timp $O(mn)$ deoarece avem un $for$ cu $m$ în cadrul unui alt for cu $m$ instrucțiuni.

În figura \ref{fig:parcurgmatrix} avem un reprezentarea vizuală a algoritmului 
\ref{alg:matrixparcurg} pentru o matrice de $3\times4$.
\begin{figure}[H] 
	\centering	
	{
		\Image[width=0.7\textwidth]{structuridedate/parcurgmatrix}
	}
	\caption{Parcurgerea și inițializarea elementelor unei matrice.} 
	\label{fig:parcurgmatrix}
\end{figure}


\subsection{Matrice rare}

O matrice rară este un tip special de matrice în care majoritatea elementelor sunt zero. Stocarea fiecărei valori într-o structură de tip matrice devine astfel ineficientă. Astfel o optimizare constă în memorarea valorilor non-zero și a pozițiilor acestora.

Pentru matricea din figura \ref{fig:sparse} putem creea o structură de tip matrice cu 3 coloane și atâtea linii câte elemente non-zero sunt în matricea inițială. Tabelul \ref{table:sparse} conține soluția de reprezentare a matricii sparse.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=0.4\textwidth]{structuridedate/sparse}
	}
	\caption{Matricea rară inițială.} 
	\label{fig:sparse}
\end{figure}



\begin{table}[h]
	\centering
	\begin{tabular}{ c c c }
		3 & 1 & 1 \\ 
		8 & 2 & 3 \\  
		17 & 3 & 2 \\    	
		9 & 3 & 4 
	\end{tabular}
	\caption{Reprezentarea unei matrici rare}
	\label{table:sparse}
\end{table}

Metoda este eficientă deoarece în loc de 12 locații, necesită doar 4, parcurgerea făcându-se de trei ori mai rapid în acest caz. Totdată, matricea originală poate fi refăcută oricând, dacă este necesar.

\newpage


\section{Liste}

O listă înlănțuită este o structură ce are ca fundație $nodul$. Un nod este o entitate formată din două părți: legătura și data. În dată sunt stocate valorile nodurilor care pot fi de simple: intregi, float-uri, caractere sau complexe precum obiecte de diverse tipuri.

O reprezentare în pseudocod a unui nod cea de mai jos:

		\begin{lstlisting}
		struct {
		Data d;
		Nod next;
		} Nod;
		\end{lstlisting}		

Aici $d$ are tipul $Data$ adică poate fi orice tip de dată, așa cum s-a indicat mai sus, iar $next$ este legătura către următorul element din listă. În cazul în care în listă nu există decât un element, valoarea lui $next$ este $NULL$.

O reprezentare vizuală a unei liste înlănțuite este în figura \ref{fig:linkedlist} unde avem 3 elemente. Primul element se mai numește $capul$ listei iar ultimul element conține în $next$ valoarea $NULL$.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{structuridedate/linkedlist}
	}
	\caption{Lista simplu înlănțuită.} 
	\label{fig:linkedlist}
\end{figure}


Lista din figura de \ref{fig:linkedlist} este o listă simplu înlănțuită adică fiecare element are legătură către un singur element din listă și anume către următorul. Această listă notată cu $L$ conține 3 elemente dintre care cel cu data $d1$ este primul element din listă, cel cu data $d3$ fiind evident ultimul element din listă.
Vom vedea în continuare că listele fi dublu și multiplu înlănțuite și cum anume se realizează aceasta.

Orice listă trebuie să permită implementarea celor 4 operațiuni de bază:

\begin{itemize}
\item {Inserare}
\item {Modificare}
\item {Căutare/Parcurgere}
\item {Ștergere}
\end{itemize}

În cele urmează vom trata fiecare operațiune în parte.

\subsection{Operațiuni cu liste simplu înlanțuite}

\subsubsection{Inserarea}

Pentru a crea un element și a-l adăuga într-o listă, trebuie mai întâi să alocăm memorie pentru noul nod și apoi să stabilim locația din listă, unde va fi acesta inserat.
Pentru a insera un element la începutul listei va trebui ca el să devină primul element și legătura sa $next$ să fie către restul listei.

Algoritmul pentru inserare la începutul listei este \ref{alg:insertbegining}.

\begin{algorithm}[H]
	\caption{Inserare la începutul listei}\label{alg:insertbegining}
	\begin{algorithmic}[1]
		\Procedure{Insert\_Beginning}{$L, val$} \\		
		\Comment Alocăm memorie pentru noul nod \hfill \tab{}\tab{}\tab{}
		\State $newnode \gets new \hspace{3pt} Node$\\
		\Comment Atribuim valoarea specifică acestuia \hfill \tab{}\tab{}\tab{}
		\State $newnode.d \gets val$\\
		\Comment Nodul are ca referință toată lista inițială  \hfill \tab{}\tab{}\tab{}
		\State $newnode.next \gets L$\\
		\Comment El devine lista. \hfill \tab{}\tab{}\tab{}\tab{}\tab{}
		\State $L \gets newnode$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Figura \ref{fig:insertbeginning} prezintă inserarea unui nou nod în lista $L$. Noul nod (cu valoarea $d$) va deveni capul listei $L$. Complexitatea acestui algoritm este $O(1)$ deoarece nu necesită decât 4 pași.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{structuridedate/insertbeginning}
	}
	\caption{Inserarea unui nou element la începutul listei.} 
	\label{fig:insertbeginning}
\end{figure}

Pentru a insera un element la sfârșitul listei va trebui mai întâi să parcurgem lista și apoi să fie referențiat de ultimul nod din listă. Astfel noul nod devine ultimul element din listă.

Algoritmul pentru inserarea unui element în listă, la finalul acesteia, este  \ref{fig:insertend}.

\begin{algorithm}[H]
	\caption{Inserare la finalul listei}\label{alg:insertend}
	\begin{algorithmic}[1]
		\Procedure{Insert\_End}{$L, val$} \\		
		\Comment Alocăm memorie pentru noul nod \hfill \tab{}\tab{}\tab{}
		\State $newnode \gets new \hspace{3pt} Node$\\
		\Comment Atribuim valoarea specifică acestuia \hfill \tab{}\tab{}\tab{}
		\State $newnode.d \gets val$\\
		\Comment Parcurgem lista L folosind un nod auxiliar  \hfill \tab{}\tab{}
		\State $auxnode \gets L$
		\While {$auxnode.next \neq  NULL$}
		\State $auxnode \gets auxnode.next$
		\EndWhile 	\\
		\Comment La final inserăm nodul în listă  \hfill \tab{}\tab{}\tab{}	
		\State $auxnode.next \gets newnode$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Inserarea la finalul listei are reprezentarea vizuală în figura \ref{fig:insertend}. Noul element se inserează prin rescrierea $next$-ului ultimului element. Noul element indică automat către $NULL$ încă din momentul creerii lui.


\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{structuridedate/insertend}
	}
	\caption{Inserarea unui nou element la finalul listei.} 
	\label{fig:insertend}
\end{figure}

Ordinul de timp al acestui algoritm este $O(n)$ deoarece trebuie parcursă întreaga listă.

Pentru a insera un nod după orice poziție din listă va trebui să parcurgem lista până la elementul căutat și va trebui să-i refacem referințele acestuia. Totodată noul nod va trebui să pointeze către următorul element, cel de după poziția căutată.

\begin{algorithm}[H]
	\caption{Inserare în interiorul listei}\label{alg:insertinterior}
	\begin{algorithmic}[1]
		\Procedure{Insert\_End}{$L, x, val$} \\		
		\Comment Alocăm memorie pentru noul nod \hfill \tab{}\tab{}\tab{}
		\State $newnode \gets new \hspace{3pt} Node$\\
		\Comment Atribuim valoarea specifică acestuia \hfill \tab{}\tab{}\tab{}
		\State $newnode.d \gets val$\\
		\Comment Parcurgem lista L folosind un nod auxiliar  \hfill \tab{}\tab{}
		\State $auxnode \gets L$\\
		\Comment până când găsim elementul după care dorim inserția  \hfill \tab{}
		\While {$auxnode.d \neq  x$}
		\State $auxnode \gets auxnode.next$
		\EndWhile 	\\
		\Comment Inserăm nodul în listă suprascriind 2 referințe: \hfill \tab{} \tab{} \\
		\Comment noul nod pointează către restul neparcurs al listei\hfill \tab{} 
		\State $newnode.next \gets auxnode.next$\\
		\Comment și nodul anterior va pointa către noul nod\hfill  \tab{} \tab{}
		\State $auxnode.next \gets newnode$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Inserarea în interiorul listei are reprezentarea vizuală în figura \ref{fig:insertinterior}. Noul element se inserează prin rescrierea celor 2 leături marcate cu verde. Se presupune că $x=d2$.

\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{structuridedate/insertinterior}
	}
	\caption{Inserarea unui nou element la finalul listei.} 
	\label{fig:insertinterior}
\end{figure}

\subsubsection{Modificarea unui element din listă}

Modificarea valorii unui element din listă poate fi realizată prin cel puțin două strategii. Dacă se cunoaște valoarea elementului din listă se parcurge lista exact ca în algoritmul \ref{alg:insertinterior}. Atunci când elementul este găsit, se modifică valoarea $d$ a obiectului.

Dacă se cunoaște poziția în listă a elementului după care se dorește inserarea, atunci algoritmul \ref{alg:insertinterioratpoz} este mai indicat.

\begin{algorithm}[H]
	\caption{Modificarea unui elementdin listă}\label{alg:insertinterioratpoz}
	\begin{algorithmic}[1]
		\Procedure{ChangeAtPosition}{$L, poz, val$} \\				
		\Comment Parcurgem lista L folosind un nod auxiliar  \hfill \tab{}\tab{}
		\State $auxnode \gets L$
		\State $i \gets 1$\\
		\Comment până când găsim elementul de modificat  \hfill \tab{} \tab{}
		\While {$poz \neq  i$}
		\State $i \gets i+1$
		\EndWhile 	\\
		\Comment Modificăm valoarea nodului curent \hfill \tab{} \tab{} \tab{} 
		\State $auxnode.d \gets aval$
\EndProcedure
	\end{algorithmic}
\end{algorithm}

Evident algoritmul pornește de la prezumția că poziția introdusă $poz$ este mai mică decât numărul de elemente din listă. Se poate adăuga o validare la începutul algoritmului care să verifice acest lucru, în caz contrar restul procedurii să nu se execute.

\subsubsection{Parcurgerea unei liste}

Algoritmul de parcurgere a unei liste este foarte asemănător celor de mai sus și anume reprezentat de \ref{alg:parcurg}.

\begin{algorithm}[H]
	\caption{Parcurgerea unei liste}\label{alg:parcurg}
	\begin{algorithmic}[1]
		\Procedure{Traverse}{$L, poz, val$} \\				
		\Comment Parcurgem lista L folosind un nod auxiliar  \hfill \tab{}\tab{}
		\State $auxnode \gets L$		
		\While {$auxnode \neq  NULL$}
		\State \textbf{Print }  $auxnode.d$
		\State $auxnode \gets auxnode.next$
		\EndWhile 	
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Scopul acestei parcurgeri este de a afișa toate elementele unei liste. În cazul în care se dorește căutarea unui element de o anumită valoare atunci se va modifica linia 5.

\subsubsection{Ștergerea unui element din listă}

Ca și în cazul inserării, există 3 posibilități: ștergerea primului element, la final și în interiorul listei.

Ștergerea primului element din listă înseamnă defapt înlocuirea listei cu elementul următor.


\begin{algorithm}[H]
	\caption{Ștergere la începutul listei}\label{alg:deletebegin}
	\begin{algorithmic}[1]
		\Procedure{Delete\_Beginning}{$L$} \\	
		\Comment Preluăm lista L folosind un nod auxiliar  \hfill \tab{}\tab{}
		\State $auxnode \gets L$\\		
		\Comment Ștergem primul nod, ignorând-ul  \hfill \tab{}\tab{}\tab{}	
		\State $L \gets auxnode.next$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Conform figurii \ref{fig:deletebeginning}, noul $cap$ al listei devine elementul cu data $d2$. Legătura care se distruge prin instrucțiunea 4 din algoritmul \ref{alg:deletebegin} este cea indicată cu roșu în figură.


\begin{figure}[H] 
	\centering	
	{
		\Image[width=\textwidth]{structuridedate/deletebeginning}
	}
	\caption{Ștergerea unui nou element de la începutul listei.} 
	\label{fig:deletebeginning}
\end{figure}




\subsection{Stiva}

Stiva și coada sunt mulţimi dinamice în care un element va fi adăugat sau șters prin intermediul unor operaţii specifice. Într-o stivă, elementul șters va fi acela care a fost introdus cel mai recent în structură. Astfel stiva este o structură de dată de tip last-in first out, sau LIFO. Pe de altă parte, coada este structura de date în care ștergerea are loc conform regulii: first-in, first-out sau FIFO.

\subsection{Operații pe structuri dinamice}

Mai jos sunt prezentate tipurile de operaţii care pot fi efectuate pe mulţimi dinamice (cu număr extensibil de elemente). Acestea sunt sub forma unor proceduri, pentru a abstractiza mediul de programare folosit. Operaţiile se împart în două tipuri: interogare ( vor returna informaţii despre elementele din mulţime) și modificare( vor modifica elemente din mulţime).

\begin{enumerate}
	\item {
		Interogare
		\begin{enumerate}
			\item {
				SEARCH(S,k) – O interogare în care, fiind dată structura de date S, și o valoare k, se va returna o valoare x, care reprezintă un pointer la un element din S astfel ca key[x]=k sau NULL dacă valoarea k nu aparţine lui S.
			}
			\item {
				MINIMUM(S) – O interogare a întregii mulţimi S ce va returna elementul din S cu cea mai mică valoare.
			}
			\item {
				MAXIMUM(S) – O interogare a întregii mulţimi S ce va returna elementul din S cu cea mai mare valoare.
			}
			\item {
				SUCCESOR(S,x) – O interogare care, pentru un element dat x, a cărei 	cheie(valoare) aparţine lui S, și care va returna următorul element din S, sau NULL dacă după x nu mai urmează nici un alt element.
			}
			\item {
				PREDECESOR(S,x) – O interogare care, pentru un element dat x, a cărei 	cheie(valoare) aparţine lui S, și care va returna precedentul element din S, sau NULL dacă înaintea lui x nu mai există nici un alt element.
			}
		\end{enumerate}
	}
	\item {
		Modificare
		\begin{enumerate}
			\item {
				INSERT(S, x) – o operaţie ce mărește mulţimea S cu un element indicat de x.
				Presupunem că orice câmp din elementul x a fost anterior iniţializat.
			}
			\item {
				DELETE(S, x) – o operaţie ce șterge elementul indicat de x din mulţimea S.
				Operaţia folosește un pointer la elementul x, și nu o valoare.
			}
		\end{enumerate}
	}
\end{enumerate}


\subsection{Stiva}

Operaţia INSERT de mai sus se numește în cazul stivei și PUSH, iar DELETE (operaţie care nu ia ca argument pe x) se numește POP. Aceste nume sunt consacrate și provin de la ordinea in care farfuriile sunt aranjate în stive, în restaurante de exemplu.
Așa cum apare în \ref{fig:structuriDate1}, se poate implementa o stivă cu n elemente $\left [ 1..n \right ]$. Șirul are un atribut \textit{top} $\left [ S \right ] $ care reprezintă elementul cel mai recent adăugat în stivă sau altfel spus, vârful stivei.
Stiva constă din elementele \textit{S}$\left [ 1..\textit{top} \left [ S \right ] \right ]$ unde \textit{S}$\left [ 1 \right ]$ este elementul de la baza stivei și \textit{S}$\left [ \textit{top}\left [ S \right ] \right ]$ este elementul din vârf.
Atunci când \textit{top}$\left [ S \right ] = 1$ se zice că stiva este goală. Dacă se încearcă scoaterea unui element din stivă goală, spunem că stiva va avea un \textit{underflow}, adică o operaţie eronată.
Atunci când \textit{top}$\left [ S \right ]$ depășește \textit{n} – numărul de elemente din stivă, se cheamă că stiva are un \textit{overflow}, de asemenea o operaţie eronată.

\begin{figure}[ht] %  \VR and h=here, t=top, b=bottom
	\centering	
		\Image[width=0.85\textwidth]{?} 
		\caption{?} 
		\label{fig:structuriDate1}
	\end{figure}


În algoritmii \ref{alg:stiva_push} și \ref{alg:stiva_pop} vom prezenta pseudocodul pentru operaţiile descrise mai sus.

\begin{algorithm} [H]
	\caption{\textit{PUSH $\left ( S, x \right )$}}\label{alg:stiva_push}
	\begin{algorithmic}[1]
		\State $top[S]\gets top[S] + 1$
		\State $S[top[S]]\gets x$
	\end{algorithmic}
\end{algorithm}


\begin{algorithm} [H]
	\caption{\textit{POP $\left ( S \right )$}}\label{alg:stiva_pop}
	\begin{algorithmic}[1]
		\If{STACK\_EMPTY(S)} 
		\State 	$\textbf{error} "underflow"$	
		\Else 
		\State $top[S]\gets top[S] - 1$
		\EndIf	
		\State \textbf{return} ${S[top[S] + 1]}$	
	\end{algorithmic}
\end{algorithm}

Procedura de verificare dacă stiva este sau nu goală se gaseste in algoritmul \ref{alg:stiva_verificare}:

\begin{algorithm} [H]
	\caption{\textit{STACK\_EMPTY $\left ( S \right )$}}\label{alg:stiva_verificare}
	\begin{algorithmic}[1]
		\If{top[S] = 0} 
		\State \textbf{return} TRUE	
		\Else 
		\State \textbf{return} FALSE
		\EndIf				
	\end{algorithmic}
\end{algorithm}

În cele ce urmează vom exemplifica folosirea stivei ca structură de dată pentru rezolvarea formei postfixate a unei expresii aritmetice.

\subsection{Expresii aritmetice postfixate}

Notaţia infixată a unei expresii este 3+4 iar notaţia prefixată sau denumită și poloneză este + 3 4. Denumirea de forma poloneză provine de la matematicianul polonez Jan Lukasiewicz. De ce folosim această notaţie? În forma poloneză, operatorii sunt plasaţi după operanzi, după cum am arătat mai sus. Dacă sunt operaţii multiple, operatorul va urma după al doilea operand, așa încât expresia 3 − 4+5 va fi scrisă 3 4 − 5 +marcând faptul că scădem 4 din 3 și apoi adunăm la suma nou obţinută 5. Avantajul acestei notaţii este că elimină necesitatea parantezelor din notaţia infixată. De exemplu expresia 3−4∗ 5 poate fi scrisă ca 3 − (4 ∗ 5), dar scrisă ca (3 − 4) ∗ 5 are cu totul alt înţeles și rezultat. În forma posfixată vom scrie expresia 3−4∗ 5 ca 3 4 5 ∗ − ce înseamnă clar, 3 ( 4 5 ∗ ) −
adică 3 20 −.
Cum funcţionează? Pentru evaluarea unei expresii operanzii sunt plasaţi pe o stivă, iar în
momentul efectuării operaţiei, operanzii sunt scoși, cu ei se va efectua operaţia, iar rezultatul acesteia va fi plasat înapoi în stivă. Practic la final, valoarea expresiei postfixate, se află în vârful stivei.

\subsection{Aplicații practice}

\begin{itemize}
	\item Calculele au loc imediat ce operatorul este specificat. În acest fel, expresiile nu sunt evaluate ca un bloc de la stânga la dreapta, ci calculate bucată cu bucată, eficientizând timpul de
	calcul.
	\item Stiva permite stocarea unui rezultat intermediar pentru a fi folosit mai târziu, ceea ce permite calculatoarelor ce folosesc această formă, să evalueze expresii de orice complexitate, spre deosebire de calculatoarele algebrice.
	\item Parantezele de orice tip nu mai sunt necesare, calculele sunt deci mai simplu efectuate.
	\item Calculatoarele au implementate această metodă de calcul a expresiilor, expresiile infixate fiind folosite pentru ca oamenii să înţeleagă sensul algebric al acestora.
\end{itemize}

\subsection{Algoritmul de evaluare a unei expresii postfixate}

\begin{algorithm} [H]
	\caption{}\label{alg:expresii_postfixate}
	\begin{algorithmic}[1]
		\While{\textit{mai există cuvinte în expresie}}
		\State \textbf{citește} \textit{cuvântul următor}	
		\If{\textit{cuvântul este o valoare}} 
		\State \textbf{push} (\textit{cuvânt})	
		\Else \textit{ cuvântul este un operator}
		\State \textbf{pop()} \textit{două valori de pe stivă}
		\State \textbf{rezultat} = \textit{operația aplicată pe cele două valori}
		\State \textbf{push(rezultat)}
		\EndIf		
		\EndWhile
		\State \textbf{rezultat final = pop()}			
	\end{algorithmic}
\end{algorithm}

Algoritmul prezentat nu tratează eventualele erori de \textit{underflow} ce apar de obicei atunci când expresia furnizată nu este validă. Pentru aceasta, va trebui să fie inserate operaţii de verificare dacă stiva este sau nu goală, iar în acest caz să aruncăm o excepţie sau un mesaj.

\subsection{Exemplu de folosire a algoritmului}

Vom evalua expresia infixată 5 + ((1 + 2) * 4) - 3 ce poate fi scrisă sub forma
postfixată astfel:
 5 1 2 + 4 ∗ + 3 −
Mai jos este prezentată secvenţa de pași prin care este evaluată expresia de mai sus
conform algoritmului \ref{alg:expresii_postfixate}.
